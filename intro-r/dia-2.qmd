---
title: "Dia 2 - Importação e transformação"
---

## Importação de dados

### Dados utilizados: Eleicões de 2024

Os dados que utilizaremos nesse curso são provenientes de uma base de dados do Tribunal Superior Eleitoral (TSE) do Brasil, que contém informações sobre candidatos para as eleições de 2024. A base de dados original foi baixada do [portal de dados abertos do TSE](https://dadosabertos.tse.jus.br/dataset/candidatos-2024): Candidatos - 2024 . Para facilitar o download dos dados durante a atividade, [filtramos a tabela](https://github.com/beatrizmilz/2025-07-fbcp/blob/main/intro-r/dados/prep-dados.R) para dados do município de São Paulo.


Junto aos dados, o TSE disponibiliza também um arquivo chamado [`leiame.pdf`](https://github.com/beatrizmilz/2025-07-fbcp/blob/main/intro-r/dados/leiame-candidatos.pdf), com informações importantes sobre os dados, significado dos nomes das colunas, entre outros. É importante ler estes arquivos, quando disponibilizados.

Vamos utilizar o pacote tidyverse para importar os dados, então é importante garantir que ele esteja carregado:

```{r}
library(tidyverse)
```

O arquivo que queremos importar é [esse aqui: candidatos_muni_sp.csv](https://raw.githubusercontent.com/beatrizmilz/2025-07-fbcp/refs/heads/main/intro-r/dados/candidatos_muni_sp.csv). Ele é um arquivo `.csv` (CSV = *comma separated values*, ou valores separados por vírgula), porém o separador utilizado é o `;`.

Para importar esse arquivo, podemos utilizar a função `read_csv2()` (a função `read_csv()` é utilizada para importar tabelas com valores separados por vírgula):

```{r}
#| eval: false
dados <- read_csv2("https://raw.githubusercontent.com/beatrizmilz/2025-07-fbcp/refs/heads/main/intro-r/dados/candidatos_muni_sp.csv")
```

Caso o arquivo esteja salvo no projeto, também podemos importar os dados utilizando o caminho relativo do arquivo:

```{r}
dados <- read_csv2("dados/candidatos_muni_sp.csv")
```


A função `View()` pode ser utilizada para visualizar os dados em uma tabela interativa:

```{r}
#| eval: false
View(dados)
```


::: {.callout-note}
As funções de importação costumam ser específicas para o tipo de arquivo que você está tentando importar. Abaixo estão algumas das funções mais comuns do pacote `readr` e outros pacotes para importar diferentes tipos de arquivos:

| Função | Pacote | Extensão do arquivo | Descrição |
|---|---|---|-----------|
| `read_csv()` | `readr` |  `.csv` | Separador: `,` |
| `read_csv2()` | `readr` | `.csv` | Separador: `;` |
| `read_delim()` | `readr` | `.txt`, `.tsv`,`.csv`, etc. | Permite especificar o separador |
| `read_rds()` | `readr` | `.rds` | Importa arquivos RDS (R data files) |
| `read_excel()` | `readxl` | `.xlsx`, `.xls` | Importa arquivos do Excel |
| `read_sheet()` | `googlesheets4` | - | Importa planilhas do Google Sheets |
| `read_sf()` | `sf` | `.geojson`, `.shp`, etc. | Importa dados espaciais (geográficos) |
| `read_parquet()` | `arrow` | `.parquet` | Importa arquivos Parquet (formato de armazenamento colunar) |

:::



### Conhecendo a base de dados

Para conhecer melhor a base de dados, podemos utilizar algumas funções para explorar as colunas e os tipos de dados.

A função `nrow()` nos mostra o número de linhas da base de dados, e a função `ncol()` nos mostra o número de colunas:

```{r}
nrow(dados)
ncol(dados)
```


A função `colnames()` nos mostra os nomes das colunas:

```{r}
colnames(dados)
```


A função `head()` nos mostra as primeiras linhas da base de dados, e a função `tail()` nos mostra as últimas linhas:

```{r}
head(dados)
tail(dados)
```

A função `glimpse()` apresenta várias informações relevantes: número de linhas, número de colunas, nome das colunas, valores de algumas observações, etc.

```{r}
glimpse(dados)
```

## Transformação de dados

Vamos conhecer as funções mais importantes do pacote `dplyr` para transformação de dados (também conhecido como manipulação de dados - *data wrangling*).


## Conhecendo o operador pipe (`|>`)

O operador pipe (`|>` ou `%>%`) permite encadear operações de forma mais legível e intuitiva.

Por exemplo, podemos utilizar o operador pipe para aplicar a função `glimpse()` diretamente nos dados:

```{r}
#| eval: false
dados |> 
  glimpse()
```

Com apenas uma função, não é tão óbvio o benefício do operador pipe. No entanto, quando começamos a encadear várias funções, ele se torna muito útil. Veremos exemplos disso ao longo desta aula!

## Principais funções do `dplyr`

O pacote `dplyr` é uma das ferramentas mais poderosas para manipulação de dados no R. Ele oferece uma série de funções que facilitam a transformação e análise de dados. Vamos conhecer algumas das principais funções do `dplyr`:

-  `distinct()`: retorna linhas únicas de um data frame (ou um conjunto de colunas), removendo duplicatas.

-   `filter()`: filtra linhas com base em condições específicas.

-   `select()`: seleciona colunas específicas de um data frame.

-   `mutate()`: adiciona ou modifica colunas.

-   `arrange()`: ordena as linhas de um data frame com base em uma ou mais colunas.

-   `summarise()`: resume os dados, calculando estatísticas agregadas.

-   `group_by()`: agrupa os dados com base em uma ou mais colunas, permitindo aplicar funções de resumo a cada grupo.

Ao apresentar essas funções, não vamos abordar todos os casos de uso, mas sim o básico de cada uma delas. Você pode consultar os materiais extras para aprender mais sobre cada função e suas possibilidades.

## Obtendo linhas únicas com `distinct()`

A função `distinct()` é utilizada para obter os **valores distintos** de um data frame, removendo duplicatas. Ela pode ser aplicada a todas as colunas ou a um subconjunto delas.

Podemos consultar quais são as categorias disponíveis na coluna `DS_CARGO` (Descrição do Cargo), utilizando a função `distinct()`:

```{r}
dados |> 
  distinct(DS_CARGO)
```
Com isso, sabemos que os dados apresentam resultados para os cargos de vereador, prefeito e vice-prefeito.

Podemos saber também quais são os valores distintos da coluna `DS_SIT_TOT_TURNO` (descrição da situação de totalização da candidata ou candidato no turno):

```{r}
dados |> 
  distinct(DS_CARGO, DS_SIT_TOT_TURNO)
```

Com esses resultados, sabemos que para o cargo de vereador(a), temos as seguintes categorias: [eleito por QP (quociente partidário)](https://www.tse.jus.br/comunicacao/noticias/2024/Marco/quocientes-eleitoral-e-partidario-entenda-como-um-candidato-a-vereador-e-eleito), eleito por média, suplente, não eleito e `#NULO`. Para o cargo de prefeito(a) e vice-prefeito(a), temos as seguintes categorias: eleito, 2º turno, não eleito.

## Filtrando dados com `filter()`

A função `filter()` é utilizada para filtrar linhas de um data frame com base em condições específicas.

Por exemplo, podemos filtrar apenas as linhas com resultados de candidatos(as) a vereador(a), utilizando a coluna `DS_CARGO` (Descrição do Cargo). Para isso, utilizamos o operador de comparação `==` (igualdade):

```{r}
dados_vereadores <- dados |>
  filter(DS_CARGO == "VEREADOR")

dados_vereadores
```

Podemos também filtrar com mais de uma condição. Por exemplo, podemos filtrar apenas os resultados de candidatos(as) a vereador(a) que foram eleitos por quociente partidário (QP) ou por média. Neste caso, usamos o operador `%in%`, que permite verificar se um valor está presente em um vetor (`c()`) de valores.

```{r}
dados_vereadores_eleitos <- dados_vereadores |>
  filter(DS_SIT_TOT_TURNO %in% c("ELEITO POR QP", "ELEITO POR MÉDIA"))

dados_vereadores_eleitos
```

A tabela filtrada tem 55 linhas, ou seja, foram eleitos 55 vereadores(as) na cidade de São Paulo nas eleições de 2024.


Ao filtrar, podemos combinar várias condições utilizando os operadores lógicos (como o `|` (OU) e o `!` (NEGAÇÃO)).

## Selecionando colunas com `select()`

A função `select()` é utilizada para selecionar colunas específicas de um data frame.

Por exemplo, podemos selecionar apenas um conjunto de colunas de interesse:

```{r}
dados_vereadores_eleitos |>
  select(NM_URNA_CANDIDATO, SG_PARTIDO, NM_PARTIDO)
```

Podemos também indicar quais colunas queremos excluir, utilizando o operador `-` antes do nome da coluna. Por exemplo, para excluir as colunas `ano` e `uf`, podemos fazer o seguinte:

```{r}
dados_vereadores_eleitos |>
  select(-DT_GERACAO, -HH_GERACAO)
```

## Adicionando ou modificando colunas com `mutate()`

A função `mutate()` é utilizada para adicionar novas colunas ou modificar colunas existentes em um data frame.

A sintaxe básica da função `mutate()` é:

```{r}
#| eval: false
base_de_dados |> 
  mutate(nome_da_nova_coluna = o_que_queremos_que_seja_salvo_nela)
```

A função `mutate()` também pode ser utilizada para modificar colunas existentes.

Por exemplo, podemos criar uma coluna nova chamada `idade` a partir da coluna `DT_NASCIMENTO` (data de nascimento) e da data da eleição:

```{r}
dados_com_idade <- dados |>
  mutate(
    # convertendo a coluna DT_NASCIMENTO para o formato de data
    data_de_nascimento = parse_date(DT_NASCIMENTO, format = "%d/%m/%Y"),
    data_da_eleicao = parse_date(DT_ELEICAO, format = "%d/%m/%Y"),
    # criando a coluna idade a partir da diferença entre as duas datas
    idade = floor(interval(data_de_nascimento, data_da_eleicao) / years(1))  # idade em anos 
  ) 
```

## Agrupando dados com `group_by()`

A função `group_by()` é utilizada para agrupar os dados com base em uma ou mais colunas. Isso é especialmente útil quando queremos aplicar funções de resumo a cada grupo.

Por exemplo, podemos agrupar os dados por colunas relacionado aos partidos:

```{r}
dados_vereadores_eleitos |>
  group_by(SG_PARTIDO, NM_PARTIDO) 
```

A função `group_by()` não altera os dados, mas prepara o data frame para que possamos aplicar funções de resumo a cada grupo. Portanto, ela é frequentemente utilizada em conjunto com a função `summarise()`.

Obs: após usar a função `group_by()`, é importante lembrar de utilizar a função `ungroup()` para remover o agrupamento, caso não seja mais necessário. Isso pode evitar problemas em operações futuras.

## Resumindo dados com `summarise()`

A função `summarise()` é utilizada para resumir os dados, calculando estatísticas agregadas. Ela é frequentemente utilizada em conjunto com a função `group_by()`.

```{r}
quantidade_eleitos_por_partido <- dados_vereadores_eleitos |>
  # agrupando por colunas com informações dos partidos
  group_by(SG_PARTIDO, NM_PARTIDO) |> 
  summarise(
    # contando o número de candidatos por grupo
    quantidade_candidatos_eleitos = n(),  
  ) |> 
   # removendo o agrupamento
  ungroup() 

quantidade_eleitos_por_partido
```

## Ordenando dados com `arrange()`

A função `arrange()` é utilizada para ordenar as linhas de um data frame com base em uma ou mais colunas.

Podemos ordenar os dados de `quantidade_eleitos_por_partido` pela coluna `quantidade_candidatos_eleitos`, utilizando a função `arrange()`. Mas atenção: por padrão, a função `arrange()` ordena os dados em ordem crescente.

```{r}
quantidade_eleitos_por_partido |>
  arrange(quantidade_candidatos_eleitos)
```
Aparentemente, existem alguns candidatos que não receberam votos válidos.


Também podemos ordenar os dados em ordem decrescente, utilizando a função `desc()`:

```{r}
quantidade_eleitos_por_partido_ordenado <- quantidade_eleitos_por_partido |>
  arrange(desc(quantidade_candidatos_eleitos))

quantidade_eleitos_por_partido_ordenado
```


## Escrevendo dados com `write_csv()` ou `writexl::write_xlsx()`

Podemos salvar o resultado em um arquivo CSV ou Excel, utilizando as funções `readr::write_csv()` ou `writexl::write_xlsx()`:

```{r}
#| eval: false
write_csv(quantidade_partidos_situacao_ordenado,
          "dados/tab-quantidade_partidos_situacao_ordenado.csv")

writexl::write_xlsx(quantidade_partidos_situacao_ordenado,
                    "dados/tab-quantidade_partidos_situacao_ordenado.xlsx")
```

## Exercícios

Com essas funções, podemos explorar diversas perguntas.

Aqui estão algumas sugestões de perguntas que você pode tentar responder utilizando as funções apresentadas aqui:

1. Considerando as variáveis de gênero e cor/raça, quantos candidatos(as) a vereador(a) foram eleitos em cada grupo? Qual é a proporção de cada grupo?

::: {.callout-note collapse="true"}
## Sugestão de código
```{r}
dados_vereadores_eleitos |> 
  group_by(DS_GENERO, DS_COR_RACA) |> 
  summarise(
    n = n()  # contando o número de candidatos por grupo
  ) |>
  mutate(
    proporcao = round(n / sum(n) * 100, 1)  # calculando a proporção de cada grupo
  ) |> 
  arrange(desc(proporcao))
```
:::


2. Qual é a idade média dos candidatos(as) a vereador(a) eleitos? Lembrando que criamos a variável `idade` e salvamos ela na tabela `dados_com_idade` (porém ela tem informações para todos os cargos e não apenas para vereadores(as)).



::: {.callout-note collapse="true"}
## Sugestão de código
```{r}
dados_com_idade |> 
  filter(DS_CARGO == "VEREADOR", DS_SIT_TOT_TURNO %in% c("ELEITO POR MÉDIA", "ELEITO POR QP")) |> 
  summarise(idade_media = mean(idade, na.rm = TRUE))
```

:::


3. Considerando a variável de grau de instrução, quantos candidatos(as) a vereador(a) foram eleitos em cada grupo? 

::: {.callout-note collapse="true"}
## Sugestão de código
```{r}
dados_vereadores_eleitos |> 
  count(DS_GRAU_INSTRUCAO) |> 
  mutate(
    proporcao = round(n / sum(n) * 100, 1)  # calculando a proporção de cada grupo
  ) |> 
  arrange(desc(proporcao))
```

:::
