---
title: "Dia 2 - Importação e transformação"
---

## Importação de dados

### Dados utilizados: Eleições de 2024

Os dados que utilizaremos nesse curso são provenientes de uma base de dados do Tribunal Superior Eleitoral (TSE) do Brasil, que contém informações sobre candidatos para as eleições de 2024. A base de dados original foi baixada do [portal de dados abertos do TSE](https://dadosabertos.tse.jus.br/dataset/candidatos-2024): Candidatos - 2024. Para facilitar o download dos dados durante a atividade, [filtramos a tabela](https://github.com/beatrizmilz/2025-07-fbcp/blob/main/intro-r/dados/prep-dados.R) para dados do município de São Paulo, apenas candidatos(as) para o cargo de Vereador, e unimos com os dados de resultados (soma de votos válidos).


Junto aos dados, o TSE disponibiliza também um arquivo chamado [`leiame.pdf`](https://github.com/beatrizmilz/2025-07-fbcp/blob/main/intro-r/dados/leiame-candidatos.pdf), com informações importantes sobre os dados, significado dos nomes das colunas, entre outros. É importante ler estes arquivos, quando disponibilizados.

Vamos utilizar o pacote tidyverse para importar os dados, então é importante garantir que ele esteja carregado:

```{r}
library(tidyverse)
```

O arquivo que queremos importar é [esse aqui: candidatos_vereador_com_votos.csv](https://raw.githubusercontent.com/beatrizmilz/2025-07-fbcp/refs/heads/main/intro-r/dados/candidatos_vereador_com_votos.csv). Ele é um arquivo `.csv` (CSV = *comma separated values*, ou valores separados por vírgula), porém o separador utilizado é o `;`.

Para importar esse arquivo, podemos utilizar a função `read_csv2()` (a função `read_csv()` é utilizada para importar tabelas com valores separados por vírgula):

```{r}
#| eval: false
dados <- read_csv2("https://raw.githubusercontent.com/beatrizmilz/2025-07-fbcp/refs/heads/main/intro-r/dados/candidatos_vereador_com_votos.csv")
```

Caso o arquivo esteja salvo no projeto, também podemos importar os dados utilizando o caminho relativo do arquivo:

```{r}
dados <- read_csv2("dados/candidatos_vereador_com_votos.csv")
```


A função `View()` pode ser utilizada para visualizar os dados em uma tabela interativa:

```{r}
#| eval: false
View(dados)
```


::: {.callout-note}
As funções de importação costumam ser específicas para o tipo de arquivo que você está tentando importar. Abaixo estão algumas das funções mais comuns do pacote `readr` e outros pacotes para importar diferentes tipos de arquivos:

| Função | Pacote | Extensão do arquivo | Descrição |
|---|---|---|-----------|
| `read_csv()` | `readr` |  `.csv` | Separador: `,` |
| `read_csv2()` | `readr` | `.csv` | Separador: `;` |
| `read_delim()` | `readr` | `.txt`, `.tsv`,`.csv`, etc. | Permite especificar o separador |
| `read_rds()` | `readr` | `.rds` | Importa arquivos RDS (R data files) |
| `read_excel()` | `readxl` | `.xlsx`, `.xls` | Importa arquivos do Excel |
| `read_sheet()` | `googlesheets4` | - | Importa planilhas do Google Sheets |
| `read_sf()` | `sf` | `.geojson`, `.shp`, etc. | Importa dados espaciais (geográficos) |
| `read_parquet()` | `arrow` | `.parquet` | Importa arquivos Parquet (formato de armazenamento colunar) |

:::



### Conhecendo a base de dados

Para conhecer melhor a base de dados, podemos utilizar algumas funções para explorar as colunas e os tipos de dados.

A função `nrow()` nos mostra o número de linhas da base de dados, e a função `ncol()` nos mostra o número de colunas:

```{r}
nrow(dados)
ncol(dados)
```


A função `colnames()` nos mostra os nomes das colunas:

```{r}
colnames(dados)
```


A função `head()` nos mostra as primeiras linhas da base de dados, e a função `tail()` nos mostra as últimas linhas:

```{r}
head(dados)
tail(dados)
```

A função `glimpse()` apresenta várias informações relevantes: número de linhas, número de colunas, nome das colunas, valores de algumas observações, etc.

```{r}
glimpse(dados)
```

## Transformação de dados

Vamos conhecer as funções mais importantes do pacote `dplyr` para transformação de dados (também conhecido como manipulação de dados - *data wrangling*).


## Conhecendo o operador pipe (`|>`)

O operador pipe (`|>` ou `%>%`) permite encadear operações de forma mais legível e intuitiva.

Por exemplo, podemos utilizar o operador pipe para aplicar a função `glimpse()` diretamente nos dados:

```{r}
#| eval: false
dados |> 
  glimpse()
```

Com apenas uma função, não é tão óbvio o benefício do operador pipe. No entanto, quando começamos a encadear várias funções, ele se torna muito útil. Veremos exemplos disso ao longo desta aula!

## Principais verbos do `dplyr`

O pacote `dplyr` é uma das ferramentas mais poderosas para manipulação de dados no R. Ele oferece uma série de funções que facilitam a transformação e análise de dados. Vamos conhecer algumas das principais funções do `dplyr`:

-   `select()`: seleciona colunas específicas de um data frame.

-   `arrange()`: ordena as linhas de um data frame com base em uma ou mais colunas.

-   `filter()`: filtra linhas com base em condições específicas.

-   `mutate()`: adiciona ou modifica colunas.


-   `summarise()`: resume os dados, calculando estatísticas agregadas.

-   `group_by()`: agrupa os dados com base em uma ou mais colunas, permitindo aplicar funções de resumo a cada grupo.

Ao apresentar essas funções, não vamos abordar todos os casos de uso, mas sim o básico de cada uma delas. Você pode consultar os materiais extras para aprender mais sobre cada função e suas possibilidades.

## Selecionando colunas com `select()`

A função `select()` é utilizada para selecionar colunas específicas de um data frame.

Por exemplo, podemos selecionar apenas um conjunto de colunas de interesse:

```{r}
dados_selecionados <- dados |>
  select(NM_CANDIDATO, SG_PARTIDO, DS_SIT_TOT_TURNO, SOMA_QT_VOTOS_NOMINAIS_VALIDOS)

dados_selecionados
```

Podemos também indicar quais colunas queremos excluir, utilizando o operador `-` antes do nome da coluna. Por exemplo, para excluir as colunas `DT_GERACAO` e `HH_GERACAO`, podemos:

```{r}
dados |>
  select(-DT_GERACAO, -HH_GERACAO)
```


## Ordenando dados com `arrange()`

A função `arrange()` é utilizada para ordenar as linhas de um data frame com base em uma ou mais colunas.

Podemos ordenar os dados de `dados_selecionados` pela coluna `SOMA_QT_VOTOS_NOMINAIS_VALIDOS`, utilizando a função `arrange()`. Mas atenção: por padrão, a função `arrange()` ordena os dados em ordem crescente.

```{r}
dados_selecionados |>
  arrange(SOMA_QT_VOTOS_NOMINAIS_VALIDOS)
```
Aparentemente, existem alguns candidatos que não receberam votos válidos.


Também podemos ordenar os dados em ordem decrescente, utilizando a função `desc()`:

```{r}
dados_selecionados |>
  arrange(desc(SOMA_QT_VOTOS_NOMINAIS_VALIDOS))
```


## Filtrando dados com `filter()`

A função `filter()` é utilizada para filtrar linhas de um data frame com base em condições específicas.

Por exemplo, podemos filtrar apenas as pessoas candidatas de determinado partido (neste exemplo, da Rede).  Para isso, utilizamos o operador de comparação `==` (igualdade):

```{r}
dados |>
  filter(SG_PARTIDO == "REDE")
```

Podemos também filtrar com mais de uma condição. Por exemplo, podemos filtrar apenas os resultados de candidatos(as) a vereador(a) que foram eleitos por quociente partidário (QP) ou por média. Neste caso, usamos o operador `%in%`, que permite verificar se um valor está presente em um vetor (`c()`) de valores.

```{r}
dados_vereadores_eleitos <- dados |>
  filter(DS_SIT_TOT_TURNO %in% c("ELEITO POR QP", "ELEITO POR MÉDIA"))

dados_vereadores_eleitos
```

A tabela filtrada tem 55 linhas, ou seja, foram eleitos 55 vereadores(as) na cidade de São Paulo nas eleições de 2024.


Podemos usar filtros com números também. Por exemplo: quantos(as) candidatos(as) a vereador(a) receberam 100 mil votos válidos ou mais?

```{r}
dados_vereadores_eleitos |> 
  filter(SOMA_QT_VOTOS_NOMINAIS_VALIDOS >= 100000)
```



Ao filtrar, podemos combinar várias condições utilizando os operadores lógicos (como o `|` (OU) e o `!` (NEGAÇÃO)).


## Adicionando ou modificando colunas com `mutate()`

A função `mutate()` é utilizada para adicionar novas colunas ou modificar colunas existentes em um data frame.

A sintaxe básica da função `mutate()` é:

```{r}
#| eval: false
base_de_dados |> 
  mutate(nome_da_nova_coluna = o_que_queremos_que_seja_salvo_nela)
```

A função `mutate()` também pode ser utilizada para modificar colunas existentes.

Por exemplo, podemos criar uma nova coluna chamada `mil_votos_validos`, que representa a quantidade de votos válidos dividida por 1000, para facilitar a leitura dos números:

```{r}
dados_vereadores_eleitos |>
  mutate(
    mil_votos_validos = round(SOMA_QT_VOTOS_NOMINAIS_VALIDOS/1000, 2)
  ) 
```

## Agrupando dados com `group_by()`

A função `group_by()` é utilizada para agrupar os dados com base em uma ou mais colunas. Isso é especialmente útil quando queremos aplicar funções de resumo a cada grupo.

Por exemplo, podemos agrupar os dados por colunas relacionado aos partidos:

```{r}
dados |>
  group_by(SG_PARTIDO, NM_PARTIDO) 
```

A função `group_by()` não altera os dados, mas prepara o data frame para que possamos aplicar funções de resumo a cada grupo. Portanto, ela é frequentemente utilizada em conjunto com a função `summarise()`.

Obs: após usar a função `group_by()`, é importante lembrar de utilizar a função `ungroup()` para remover o agrupamento, caso não seja mais necessário. Isso pode evitar problemas em operações futuras.

## Resumindo dados com `summarise()`

A função `summarise()` é utilizada para resumir os dados, calculando estatísticas agregadas. Ela é frequentemente utilizada em conjunto com a função `group_by()`.

```{r}
dados_por_partido <- dados |>
  # agrupando por colunas com informações dos partidos
  group_by(SG_PARTIDO, NM_PARTIDO) |> 
  summarise(
    # contando o número de candidatos por grupo
    quantidade_candidatos = n(),  
    quantidade_eleitos = sum(DS_SIT_TOT_TURNO %in% c("ELEITO POR QP", "ELEITO POR MÉDIA"), na.rm = TRUE),  # contando o número de candidatos eleitos
    
    media_votos_por_cand = mean(SOMA_QT_VOTOS_NOMINAIS_VALIDOS, na.rm = TRUE),  # calculando a média de votos válidos
    mediana_votos_por_cand = median(SOMA_QT_VOTOS_NOMINAIS_VALIDOS, na.rm = TRUE),  # calculando a mediana de votos válidos
    soma_votos = sum(SOMA_QT_VOTOS_NOMINAIS_VALIDOS, na.rm = TRUE)  # somando os votos válidos
  ) |> 
   # removendo o agrupamento
  ungroup() |> 
  arrange(desc(quantidade_eleitos), desc(soma_votos))

dados_por_partido

# Checando o número de eleitos
sum(dados_por_partido$quantidade_eleitos)
```

## Extra: `count()`

A função `count()` é uma forma simplificada de usar `group_by()` e `summarise()`. Ela conta o número de ocorrências de cada grupo e retorna um data frame com as contagens. Por exemplo:

```{r}
dados_vereadores_eleitos |>
  count(DS_GENERO) 
```

```{r}
dados_vereadores_eleitos |>
  count(DS_GRAU_INSTRUCAO) 
```

```{r}
dados_vereadores_eleitos |>
  count(DS_COR_RACA) 
```


## Escrevendo dados com `write_csv()` ou `writexl::write_xlsx()`

Podemos salvar o resultado em um arquivo CSV ou Excel, utilizando as funções `readr::write_csv()` ou `writexl::write_xlsx()`:

```{r}
#| eval: false
write_csv(dados_por_partido,
          "dados/tab-dados_por_partido.csv")

writexl::write_xlsx(dados_por_partido,
                    "dados/tab-dados_por_partido.xlsx")
```
