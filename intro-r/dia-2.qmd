---
title: "Dia 2 - Importação e transformação"
---

::: {.callout-warning}
Página em construção.
:::

## Importação de dados

### Dados utilizados: Eleicões de 2024

Os dados que utilizaremos nesse curso são provenientes de uma base de dados do Tribunal Superior Eleitoral (TSE) do Brasil, que contém informações sobre as eleições de 2024. A base de dados original foi baixada do [portal de dados abertos do TSE](https://dadosabertos.tse.jus.br/dataset/resultados-2024): Votação nominal por município e zona. Para facilitar o download dos dados durante a atividade, [filtramos a tabela](https://github.com/beatrizmilz/2025-07-fbcp/blob/main/intro-r/dados/prep-dados.R) para dados do município de São Paulo.


Junto aos dados, o TSE disponibiliza também um arquivo chamado [`leiame.pdf`](https://github.com/beatrizmilz/2025-07-fbcp/blob/main/intro-r/dados/leiame.pdf), com informações importantes sobre os dados, significado dos nomes das colunas, entre outros. É importante ler estes arquivos, quando disponibilizados.

Vamos utilizar o pacote tidyverse para importar os dados, então é importante garantir que ele esteja carregado:

```{r}
library(tidyverse)
```

O arquivo que queremos importar é [esse aqui: votacao_muni_sp.csv](https://raw.githubusercontent.com/beatrizmilz/2025-07-fbcp/refs/heads/main/intro-r/dados/votacao_muni_sp.csv). Ele é um arquivo `.csv` (CSV = *comma separated values*, ou valores separados por vírgula), porém o separador utilizado é o `;`.

Para importar esse arquivo, podemos utilizar a função `read_csv2()` (a função `read_csv()` é utilizada para importar tabelas com valores separados por vírgula):


```{r}
#| eval: false
dados <- read_csv2("https://raw.githubusercontent.com/beatrizmilz/2025-07-fbcp/refs/heads/main/intro-r/dados/votacao_muni_sp.csv")
```

Caso o arquivo esteja salvo no projeto, também podemos importar os dados utilizando o caminho relativo do arquivo:

```{r}
dados <- read_csv2("dados/votacao_muni_sp.csv")
```


A função `View()` pode ser utilizada para visualizar os dados em uma tabela interativa:

```{r}
#| eval: false
View(dados)
```


::: {.callout-note}
As funções de importação costumam ser específicas para o tipo de arquivo que você está tentando importar. Abaixo estão algumas das funções mais comuns do pacote `readr` e outros pacotes para importar diferentes tipos de arquivos:

| Função | Pacote | Extensão do arquivo | Descrição |
|---|---|---|-----------|
| `read_csv()` | `readr` |  `.csv` | Separador: `,` |
| `read_csv2()` | `readr` | `.csv` | Separador: `;` |
| `read_delim()` | `readr` | `.txt`, `.tsv`,`.csv`, etc. | Permite especificar o separador |
| `read_rds()` | `readr` | `.rds` | Importa arquivos RDS (R data files) |
| `read_excel()` | `readxl` | `.xlsx`, `.xls` | Importa arquivos do Excel |
| `read_sheet()` | `googlesheets4` | - | Importa planilhas do Google Sheets |
| `read_sf()` | `sf` | `.geojson`, `.shp`, etc. | Importa dados espaciais (geográficos) |
| `read_parquet()` | `arrow` | `.parquet` | Importa arquivos Parquet (formato de armazenamento colunar) |

:::



### Conhecendo a base de dados

Para conhecer melhor a base de dados, podemos utilizar algumas funções para explorar as colunas e os tipos de dados.

A função `nrow()` nos mostra o número de linhas da base de dados, e a função `ncol()` nos mostra o número de colunas:

```{r}
nrow(dados)
ncol(dados)
```


A função `colnames()` nos mostra os nomes das colunas:

```{r}
colnames(dados)
```


A função `head()` nos mostra as primeiras linhas da base de dados, e a função `tail()` nos mostra as últimas linhas:

```{r}
head(dados)
tail(dados)
```

A função `glimpse()` apresenta várias informações relevantes: número de linhas, número de colunas, nome das colunas, valores de algumas observações, etc.

```{r}
glimpse(dados)
```

## Transformação de dados

Vamos conhecer as funções mais importantes do pacote `dplyr` para transformação de dados (também conhecido como manipulação de dados - *data wrangling*).


## Conhecendo o operador pipe (`|>`)

O operador pipe (`|>` ou `%>%`) permite encadear operações de forma mais legível e intuitiva.

Por exemplo, podemos utilizar o operador pipe para aplicar a função `glimpse()` diretamente nos dados:

```{r}
dados |> 
  glimpse()
```

Com apenas uma função, não é tão óbvio o benefício do operador pipe. No entanto, quando começamos a encadear várias funções, ele se torna muito útil. Veremos exemplos disso ao longo desta aula!

## Principais funções do `dplyr`

O pacote `dplyr` é uma das ferramentas mais poderosas para manipulação de dados no R. Ele oferece uma série de funções que facilitam a transformação e análise de dados. Vamos conhecer algumas das principais funções do `dplyr`:

-  `distinct()`: retorna linhas únicas de um data frame (ou um conjunto de colunas), removendo duplicatas.

-   `filter()`: filtra linhas com base em condições específicas.

-   `select()`: seleciona colunas específicas de um data frame.

-   `mutate()`: adiciona ou modifica colunas.

-   `arrange()`: ordena as linhas de um data frame com base em uma ou mais colunas.

-   `summarise()`: resume os dados, calculando estatísticas agregadas.

-   `group_by()`: agrupa os dados com base em uma ou mais colunas, permitindo aplicar funções de resumo a cada grupo.

Ao apresentar essas funções, não vamos abordar todos os casos de uso, mas sim o básico de cada uma delas. Você pode consultar os materiais extras para aprender mais sobre cada função e suas possibilidades.

## Obtendo linhas únicas com `distinct()`

A função `distinct()` é utilizada para obter os **valores distintos** de um data frame, removendo duplicatas. Ela pode ser aplicada a todas as colunas ou a um subconjunto delas.

Podemos consultar quais são as categorias disponíveis na coluna `DS_CARGO` (Descrição do Cargo), utilizando a função `distinct()`:

```{r}
dados |> 
  distinct(DS_CARGO)
```
Com isso, sabemos que os dados apresentam resultados de candidatos(as) a vereador(a) e prefeito(a).

Podemos saber também quais são os valores distintos da coluna `DS_SIT_TOT_TURNO` (descrição da situação de totalização da candidata ou
candidato no turno):

```{r}
dados |> 
  distinct(DS_CARGO, DS_SIT_TOT_TURNO)
```

Com esses resultados, sabemos que para o cargo de vereador(a), temos as seguintes categorias: [eleito por QP (quociente partidário)](https://www.tse.jus.br/comunicacao/noticias/2024/Marco/quocientes-eleitoral-e-partidario-entenda-como-um-candidato-a-vereador-e-eleito), eleito por média, suplente, não eleito. Para o cargo de prefeito(a), temos as seguintes categorias: eleito, 2º turno, não eleito.

## Filtrando dados com `filter()`

A função `filter()` é utilizada para filtrar linhas de um data frame com base em condições específicas.

Por exemplo, podemos filtrar apenas as linhas com resultados de candidatos(as) a vereador(a), utilizando a coluna `DS_CARGO` (Descrição do Cargo). Para isso, utilizamos o operador de comparação `==` (igualdade):

```{r}
dados_vereadores <- dados |>
  filter(DS_CARGO == "Vereador")

dados_vereadores
```

Podemos também filtrar com mais de uma condição. Por exemplo, podemos filtrar apenas os resultados de candidatos(as) a vereador(a) que foram eleitos por quociente partidário (QP) ou por média. Neste caso, usamos o operador `%in%`, que permite verificar se um valor está presente em um vetor (`c()`) de valores.

```{r}
dados_vereadores_eleitos <- dados_vereadores |>
  filter(DS_SIT_TOT_TURNO %in% c("ELEITO POR QP", "ELEITO POR MÉDIA"))

dados_vereadores_eleitos
```


Podemos combinar várias condições utilizando os operadores lógicos (como o `|` (OU) e o `!` (NEGAÇÃO)).

## Selecionando colunas com `select()`

A função `select()` é utilizada para selecionar colunas específicas de um data frame.

Por exemplo, podemos selecionar apenas um conjunto de colunas de interesse:

```{r}
dados_vereadores_eleitos |>
  select(NM_URNA_CANDIDATO, SG_PARTIDO, NM_PARTIDO)
```

Podemos também indicar quais colunas queremos excluir, utilizando o operador `-` antes do nome da coluna. Por exemplo, para excluir as colunas `ano` e `uf`, podemos fazer o seguinte:

```{r}
dados_vereadores_eleitos |>
  select(-DT_GERACAO, -HH_GERACAO)
```

## Adicionando ou modificando colunas com `mutate()`

A função `mutate()` é utilizada para adicionar novas colunas ou modificar colunas existentes em um data frame.

A sintaxe básica da função `mutate()` é:

```{r}
#| eval: false
base_de_dados |> 
  mutate(nome_da_nova_coluna = o_que_queremos_que_seja_salvo_nela)
```

Por exemplo, podemos criar uma coluna nova chamada `populacao_urbana_mil` que representa a população urbana em mil habitantes:

```{r}
dados |>
  # selecionando as colunas municipio e populacao_urbana
  # para facilitar a visualização
  select(municipio, populacao_urbana) |>
  mutate(populacao_urbana_mil = populacao_urbana / 1000)
```

A função `mutate()` também pode ser utilizada para modificar colunas existentes. Por exemplo, podemos mudar a classe de algumas colunas:

```{r}
dados |>
  mutate(
    ugrhi = as.character(ugrhi),  # convertendo ugrhi para character
    codigo_ibge = as.character(codigo_ibge)  # convertendo codigo_ibge para character
  )
```


## Agrupando dados com `group_by()`

A função `group_by()` é utilizada para agrupar os dados com base em uma ou mais colunas. Isso é especialmente útil quando queremos aplicar funções de resumo a cada grupo.

Por exemplo, podemos agrupar os dados por colunas relacionado aos candidatos a vereador(a) (e seus respectivos partidos):

```{r}
dados_vereadores |>
  group_by(NR_CANDIDATO, NM_CANDIDATO, NM_URNA_CANDIDATO, NM_SOCIAL_CANDIDATO, SG_PARTIDO, NM_PARTIDO) 
```
A tabela resultante apresenta 979 grupos, o que indica que houveram 979 pessoas candidatas para o cargo de vereador nas eleições municipais de 2024 no município de São Paulo. 


A função `group_by()` não altera os dados, mas prepara o data frame para que possamos aplicar funções de resumo a cada grupo. Portanto, ela é frequentemente utilizada em conjunto com a função `summarise()`.

## Resumindo dados com `summarise()`

A função `summarise()` é utilizada para resumir os dados, calculando estatísticas agregadas. Ela é frequentemente utilizada em conjunto com a função `group_by()`.


```{r}
soma_votos_validos <- dados_vereadores |>
  # agrupando por colunas com informações dos candidatos
  group_by(NM_CANDIDATO, NM_URNA_CANDIDATO, SG_PARTIDO, NM_PARTIDO, DS_SIT_TOT_TURNO) |> 
  summarise(
    # contando o número de votos válidos recebidos por cada candidato
    votos_validos = sum(QT_VOTOS_NOMINAIS_VALIDOS, na.rm = TRUE)
  )
```

## Ordenando dados com `arrange()`

A função `arrange()` é utilizada para ordenar as linhas de um data frame com base em uma ou mais colunas.

Podemos ordenar os dados de `soma_votos_validos` pela coluna `votos_validos`, utilizando a função `arrange()`. Mas atenção: por padrão, a função `arrange()` ordena os dados em ordem crescente.

```{r}
soma_votos_validos |>
  arrange(votos_validos)
```
Aparentemente, existem alguns candidatos que não receberam votos válidos.


Também podemos ordenar os dados em ordem decrescente, utilizando a função `desc()`:

```{r}
soma_votos_validos_ordenados <- soma_votos_validos |>
  arrange(desc(votos_validos))

soma_votos_validos_ordenados
```


## Escrevendo dados com `write_csv()` ou `writexl::write_xlsx()`

Podemos salvar o resultado em um arquivo CSV ou Excel, utilizando as funções `readr::write_csv()` ou `writexl::write_xlsx()`:

```{r}
#| eval: false
write_csv(soma_votos_validos_ordenados,
          "dados/tab-soma-votos-validos.csv")

writexl::write_xlsx(soma_votos_validos_ordenados,
                    "dados/tab-soma-votos-validos.xlsx")
```

## Unindo tabelas com `left_join()`

A função `left_join()` é utilizada para unir duas tabelas com base em uma ou mais colunas em comum (chamada de chave - `key`).

Para este exemplo, vamos importar [uma tabela](https://raw.githubusercontent.com/beatrizmilz/ESHT011-21-analise-dados-planejamento-territorial/refs/heads/main/praticas/dados/idhm_sp_2010.csv) que contém informações sobre o IDH (Índice de Desenvolvimento Humano) dos municípios de São Paulo, referente ao ano de 2010. Esses dados são baseados no Censo, mas ainda não temos o IDH calculado para o ano de 2022.

```{r}
dados_idhm <- read_csv("https://raw.githubusercontent.com/beatrizmilz/ESHT011-21-analise-dados-planejamento-territorial/refs/heads/main/praticas/dados/idhm_sp_2010.csv")
```

Para fazer o join, precisamos garantir que as colunas que vamos utilizar como chave estejam no mesmo formato. Neste caso, vamos utilizar a coluna referente ao código do IBGE como chave para unir as duas tabelas:

```{r}
names(dados_idhm)
names(dados)
```

É importante que a variável que usaremos como chave esteja no mesmo formato nas duas tabelas. Usamos a função `class()` para verificar o tipo de dado de cada coluna:

```{r}
class(dados$codigo_ibge)
class(dados_idhm$muni_id)
```

Obs: caso as colunas não estejam no mesmo formato, podemos utilizar a função `mutate()` para alterar o tipo de dado de uma das colunas, junto com funções como `as.character()` ou `as.numeric()`, dependendo da classe de dado que queremos.

Agora podemos unir as duas tabelas utilizando a função `left_join()`. Essa função irá manter todas as linhas da tabela da esquerda (`dados`) e adicionar as colunas da tabela da direita (`dados_idhm`) onde houver correspondência na chave especificada.

```{r}
dados_unidos <- left_join(
  # tabela da esquerda
  dados, 
  # tabela da direita
  dados_idhm, 
  # o argumento `by` especifica as colunas que serão utilizadas como chave para o join
  by = c("codigo_ibge" = "muni_id")
  )
```

A nova tabela `dados_unidos` agora contém todas as colunas de ambas as tabelas, com os dados do IDH adicionados aos municípios correspondentes. Se um município não tiver um valor correspondente na tabela de IDH, as colunas relacionadas ao IDH terão valores `NA`.

```{r}
glimpse(dados_unidos)
```


Podemos salvar os dados unidos em um arquivo CSV ou Excel, utilizando as funções `readr::write_csv()` ou `writexl::write_excel_csv()`:

```{r}
#| eval: false
write_csv(dados_unidos,
          "dados/dados-join-cetesb-idhm.csv")
```


Este caso é um exemplo de um join bem simples, onde temos uma chave única em cada tabela. No entanto, existem outros tipos de joins, como `inner_join()`, `right_join()`, `full_join()`, que podem ser utilizados dependendo da situação.



